"""
Добавить многопоточность к коду задания 2, применяя необязательный аргумент -
-t и указывая количество потоков -t 20
Сделать возможность добавлять любое расширение к полезной нагрузке.
Реализовать можно двумя вариантами:
1. В адресе хоста добавлять любое расширение
https://codeby.net/FUZZ.txt
2. С помощью опции -e и указанием нужного расширения -e txt
Такая программа становится более функциональной, так как может фаззить не
только директории, но и любые файлы.
Часть кодов с ответами на самом деле являются редиректами. Выведите
правильные ответы сервера, раскрасив ответы 3xx синим цветом, и красным 4xx.
Соответствующий запуск программы может выглядеть так:
python fuzzer.py -u https://codeby.net/FUZZ.txt -w
/usr/share/wordlists/dirbuster/directory-list-2.3-medium -t 20
python fuzzer.py -u https://codeby.net/FUZZ -w /usr/share/wordlists/dirbuster/directory-
list-2.3-medium -t 20 -e txt
"""
import requests as r
import sys
import os
import argparse as a
import threading as th
from colorama import Fore as fF

pr = a.ArgumentParser(description='Dir Fuzzer')

pr.add_argument('-u', dest='website', help='Enter domain https://site.com')
pr.add_argument('-w', dest='wordlist', help='Name and path the wordlist')
pr.add_argument('-t', type=int, dest='thread', help='количество потоков', default=1)
pr.add_argument('-e', dest='format', help='расширение файла')

args = pr.parse_args()


def greetings():
    """Функция отображает приветствие пользователя"""
    print(fF.GREEN + '''
╔═══╗╔══╗╔═══╗     ╔═══╗╔╗─╔╗╔════╗╔════╗╔═══╗╔═══╗
╚╗╔╗║╚╣║╝║╔═╗║     ║╔══╝║║─║║╚══╗═║╚══╗═║║╔══╝║╔═╗║
─║║║║─║║─║╚═╝║     ║╚══╗║║─║║──╔╝╔╝──╔╝╔╝║╚══╗║╚═╝║
─║║║║─║║─║╔╗╔╝     ║╔══╝║║─║║─╔╝╔╝──╔╝╔╝─║╔══╝║╔╗╔╝
╔╝╚╝║╔╣║╗║║║╚╗     ║║───║╚═╝║╔╝═╚═╗╔╝═╚═╗║╚══╗║║║╚╗
╚═══╝╚══╝╚╝╚═╝     ╚╝───╚═══╝╚════╝╚════╝╚═══╝╚╝╚═╝
          ''' + fF.RESET)


class Task3:
    def __init__(self):
        self.DIRS = []
        self.length = len(self.DIRS)
        if len(sys.argv) >= 2:
            self.counter = 0
            self.hostname = args.website.replace('/FUZZ', '/')
            self.check_site_annotaion()
            greetings()
            self.check_wordlist_file(args.wordlist)
        else:
            pr.print_help()
            sys.exit(0)

        if args.thread and args.format:
            for i in range(int(args.thread)):
                i = th.Thread(target=self.get_site_dirs)
                i.start()
        else:
            if args.thread and not args.format:
                for i in range(int(args.thread)):
                    i = th.Thread(target=self.get_site_dirs)
                    i.start()
            if args.format and not args.thread:
                self.get_site_dirs()

    def check_wordlist_file(self, path_to_wordlist):
        """Функция проверяет наличие файла со словарём"""
        if not os.path.isfile(path_to_wordlist):
            print(f"{path_to_wordlist}\n{fF.RED}Файл со словарём не найден.{fF.RESET}")
            sys.exit(0)
        else:
            with open(args.wordlist, "r") as reader:
                self.DIRS = [line for line in reader.readlines()]
                self.length = len(self.DIRS)
            print(f"\nЗагружено строк из словаря: {len(self.DIRS)}")
            print(f'\n{fF.GREEN}Для завершения программы нажмите CTRL + Z.{fF.RESET}')
            print(f"\nРаботаем с сайтом {self.hostname}. Путь к словарю {args.wordlist}\n")

    def check_site_annotaion(self):
        """Функция проверяет есть ли коннект с хостом"""
        try:
            response = r.get(self.hostname, headers={
                "User-Agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)"
                              " Chrome/72.0.3626.119 Safari/537.36"},
                             timeout=1)
            response.raise_for_status()
            if response.status_code == 200:
                print('\nOK!')
                print()
        except (r.exceptions.HTTPError, r.exceptions.Timeout) as e:
            print('ERROR: %s' % e)

    def get_site_dirs(self):
        """Функция проверки директорий"""
        try:
            while len(self.DIRS):
                with open('fuzz.txt', 'a', encoding='utf-8') as file:
                    if args.thread and args.format:
                        target_url = f'{self.hostname}{self.DIRS.pop(0).strip()}.{args.format}'
                    else:
                        if args.thread and not args.format:
                            target_url = f'{self.hostname}{self.DIRS.pop(0).strip()}/'
                        elif args.format and not args.thread:
                            target_url = f'{self.hostname}{self.DIRS.pop(0).strip()}.{args.format}'
                    host_answer = r.get(target_url, allow_redirects=False)
                    self.counter += 1
                    if host_answer.status_code == 200:
                        print(f"{self.counter:0>8} of {self.length}\t{fF.GREEN + str(host_answer.status_code) + fF.RESET}\t{target_url}{' ' * 100}")
                        file.write(f"{self.counter:0>8} of {self.length}\t{str(host_answer.status_code)}\t{target_url}\n")
                    elif host_answer.status_code < 300:
                        print(f"{' ' * 100}\r{self.counter:0>8} of {self.length}\t{host_answer.status_code}\t{target_url}{' ' * 100}", end='\r')
                    elif host_answer.status_code in range(300, 400):
                        print(f"{self.counter:0>8} of {self.length}\t{fF.BLUE + str(host_answer.status_code) + fF.RESET}\t{target_url}{' ' * 100}")
                        file.write(f"{self.counter:0>8} of {self.length}\t{str(host_answer.status_code)}\t{target_url}\n")
                    elif host_answer.status_code in range(400, 500):
                        print(f"{self.counter:0>8} of {self.length}\t{fF.RED + str(host_answer.status_code) + fF.RESET}\t{target_url}{' ' * 100}")
                        file.write(f"{self.counter:0>8} of {self.length}\t{str(host_answer.status_code)}\t{target_url}\n")
                    else:
                        print(f"{self.counter:0>8} of {self.length}\t{fF.GREEN + str(host_answer.status_code) + fF.RESET}\t{target_url}{' ' * 100}")
                        file.write(f"{self.counter:0>8} of {self.length}\t{str(host_answer.status_code)}\t{target_url}\n")
            else:
                raise SystemExit
        except KeyboardInterrupt:
            print(fF.RED + '  ERROR: manually stop Ctrl+C' + fF.RESET)


if __name__ == "__main__":
    target = Task3()
