"""Напишите программу, которая принимает следующие опциональные аргументы:
-d, --data
Создаёт базы данных
-t, --table
Создаёт таблицы
-c, --columns Создаёт колонки
-r, --records Создаёт строки в колонках
-i, --info
Принимает запросы в БД, и выводит результаты (версия, порт,
колонки и т.п.)
-e, --erase
Удаляет строки
-u, --update Обновляет строки
-k, --kill
Удаляет базы/таблицы
При работе с любой опцией выводите подходящее сообщение, и завершайте
работу с программой. Только опция -i, --info должна работать в бесконечном
цикле, выход из которого по команде exit с сообщением - Work with the database is
completeПри вводе некорректной команды перехватывайте исключение."""



import argparse as a
import os
import stat
import subprocess
import mysql.connector as sql

p = a.ArgumentParser(description='Database Management', usage='Script option')

p.add_argument('-d', '--data', help='Создаёт базы данных')
p.add_argument('-t', '--table', help='Создаёт таблицы')
p.add_argument('-c', '--columns', help='Создаёт колонки')
p.add_argument('-r', '--records', help='Создаёт строки в колонках')
p.add_argument('-i', '--info', help='Принимает запросы в БД, и выводит результаты')
p.add_argument('-e', '--erase', help='Удаляет строки')
p.add_argument('-u', '--update', help='Обновляет строки')
p.add_argument('-k', '--kill', help='Удаляет базы/таблицы')

args = p.parse_args()

class SQL:
    def __init__(self):
        self.db = sql.connect(host='localhost', user='pen', passwd='tester')
        self.c = db.cursor()

    def get_name(self, database=False, table=False, column=False):
        if table:
            self.tablename = input('Type the name of the table: ')
        elif column:
            self.columnsnames = input('Type the columns` names: ')
        elif database:
            self.database = input('Type the name of the database: ')
            self.c.execute('show databases')
            res = self.c.fetchall()
            if self.database not in res:
                self.c.execute(f'create database {self.database}')
        else:
            self.database = input('Type the name of the database: ')
            self.columnsnames = input('Type the name of the table: ')
            self.tablename = input('Type the columns` names: ')

    def data(self):
        ''''-d', '--data', Создаёт базы данных'''
        self.c.execute(f'create database {args.data}')
        print(f'The database {args.data} has been created!')

    def table(self):
        ''''-t', '--table', Создаёт таблицы'''
        self.get_name(database=True)
        self.c.execute(f'create table {args.table}')
        print(f'The table {args.table} has been created!')

    def columns(self):
        ''''-c', '--columns', Создаёт колонки в таблице'''
        self.get_name(database=True, table=True)
        self.c.execute(f'alter table {self.tablename} add column {args.columns}')
        db.commit()
        print(f'The column(-s) {args.columns} have been added to the {tablename} table!')

    def records(self):
        ''''-r', '--records', 'Создаёт строки в колонках'''
        self.get_name(database=True, table=True, column=True)
        self.c.execute(f'alter table {self.tablename} {"(" + self.columnsnames + ")"} values {args.records}')
        self.db.commit()
        print(self.c.rowcount, 'The information has been inserted!')

    def info(self):
        ''''-i', '--info', 'Принимает запросы в БД, и выводит результаты'''
        while (command := input('Type your command please: ')) != 'exit':
            self.c.execute(command)
            res = self.c.fetchall()
            for i in res:
                print(f'Info: {i}')
        else:
            print('Work with the database is complete.')

    def erase(self):
        ''''-e', '--erase', 'Удаляет строки'''
        self.get_name(database=True, table=True)
        self.c.execute(f'delete from {self.tablename} where {args.erase}')
        self.db.commit()
        print(c.rowcount, 'The information has been deleted!')

    def update(self):
        ''''-u', '--update', 'Обновляет строки'''
        self.get_name(database=True, table=True)
        self.c.execute(f'update {self.tablename} set {args.update}')
        self.db.commit()
        print(self.c.rowcount, 'The information has been updated!')

    def kill(self):
        ''''-k', '--kill', 'Удаляет базы/таблицы'''
        answer = input('Delete a table or a database? T/D')
        if answer.upper() == 'D':
            self.c.execute(f'drop database {args.kill}')
        else:
            self.c.execute(f'drop table {args.kill}')
        self.db.commit()
        print(f'The table/database {args.kill} has been deleted!')


mydb = SQL()
try:
    if args.data:
        mydb.data()
    elif args.table:
        mydb.table()
    elif args.columns:
        mydb.columns()
    elif args.records:
        mydb.records()
    elif args.info:
        mydb.info()
    elif args.erase:
        mydb.erase()
    elif args.update:
        mydb.update()
    elif args.kill:
        args.kill()
    else:
        p.print_help()

except Error as e:
    print(e)